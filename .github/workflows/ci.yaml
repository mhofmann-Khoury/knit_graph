# =============================================================================
# CONTINUOUS INTEGRATION WORKFLOW
# =============================================================================
# This GitHub Actions workflow runs automated quality checks on every commit
# and pull request to ensure code quality and catch issues early.
#
# Triggered on:
# - Push to main branch
# - Pull requests targeting main
# - Manual workflow dispatch
#
# The workflow runs multiple jobs in parallel for efficiency:
# - Code quality checks (linting, formatting, type checking)
# - Unit tests with coverage
# - Multi-Python version testing

name: CI

# =============================================================================
# WORKFLOW TRIGGERS
# =============================================================================
on:
  # Run on pushes to main branches
  push:
    branches:
      - main

  # Run on pull requests targeting main branches
  pull_request:
    branches:
      - main

  # Allow manual triggering from GitHub UI
  workflow_dispatch:

# =============================================================================
# WORKFLOW-LEVEL ENVIRONMENT VARIABLES
# =============================================================================
env:
  PYTHON_VERSION: "3.11"           # Primary Python version for most jobs
  POETRY_VERSION: "1.8.3"          # Updated Poetry version
  PACKAGE_NAME: "knit_graphs"

# =============================================================================
# WORKFLOW PERMISSIONS
# =============================================================================
permissions:
  contents: read                    # Read repository contents
  pull-requests: write              # Comment on pull requests with results
  checks: write                     # Write check results

# =============================================================================
# JOB DEFINITIONS
# =============================================================================
jobs:
  # ===========================================================================
  # PRE-COMMIT QUALITY CHECKS
  # ===========================================================================
  # Run all pre-commit hooks to ensure code quality
  pre-commit:
    name: Pre-commit Checks
    runs-on: ubuntu-latest

    steps:
      - name: Check out code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5  # Updated from v4 to v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: ${{ env.POETRY_VERSION }}
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: Load cached dependencies
        id: cached-poetry-dependencies
        uses: actions/cache@v4         # Updated from v3 to v4
        with:
          path: .venv
          key: venv-${{ runner.os }}-${{ env.PYTHON_VERSION }}-${{ hashFiles('**/poetry.lock') }}

      - name: Install dependencies
        if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'
        run: poetry install --no-interaction --no-root

      - name: Install project
        run: poetry install --no-interaction

      - name: Run pre-commit hooks
        run: poetry run pre-commit run --all-files

  # ===========================================================================
  # UNIT TESTS WITH COVERAGE
  # ===========================================================================
  # Run unittest suite with coverage measurement across multiple Python versions
  test:
    name: Unit Tests (Python ${{ matrix.python-version }})
    runs-on: ${{ matrix.os }}

    strategy:
      fail-fast: false              # Continue testing other versions if one fails
      matrix:
        python-version: ["3.11", "3.12", "3.13"]
        os: [ubuntu-latest, windows-latest, macos-latest]  # Test on all major platforms

    steps:
      - name: Check out code
        uses: actions/checkout@v4

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5  # Updated from v4 to v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: ${{ env.POETRY_VERSION }}
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: Load cached dependencies
        id: cached-poetry-dependencies
        uses: actions/cache@v4         # Updated from v3 to v4
        with:
          path: .venv
          key: venv-${{ runner.os }}-${{ matrix.python-version }}-${{ hashFiles('**/poetry.lock') }}

      - name: Install dependencies
        if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'
        run: poetry install --no-interaction --no-root

      - name: Install project
        run: poetry install --no-interaction

      - name: Run unittest with coverage
        run: |
          poetry run coverage run -m unittest discover tests
          poetry run coverage report

  # ===========================================================================
  # STATIC TYPE CHECKING
  # ===========================================================================
  # Dedicated job for comprehensive type checking
  type-check:
    name: Type Checking
    runs-on: ubuntu-latest

    steps:
      - name: Check out code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5  # Updated from v4 to v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: ${{ env.POETRY_VERSION }}
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: Load cached dependencies
        id: cached-poetry-dependencies
        uses: actions/cache@v4         # Updated from v3 to v4
        with:
          path: .venv
          key: venv-${{ runner.os }}-${{ env.PYTHON_VERSION }}-${{ hashFiles('**/poetry.lock') }}

      - name: Install dependencies
        if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'
        run: poetry install --no-interaction --no-root

      - name: Install project
        run: poetry install --no-interaction

      - name: Run MyPy type checking
        run: |
          # TODO: Update source directory if not using src/
          poetry run mypy src/

      - name: Upload MyPy results
        if: always()  # Upload results even if MyPy fails
        uses: actions/upload-artifact@v4  # Updated from v3 to v4
        with:
          name: mypy-results
          path: .mypy_cache/

  # ===========================================================================
  # PACKAGE BUILDING AND VALIDATION
  # ===========================================================================
  # Build the package and validate it can be installed
  build:
    name: Package Building
    runs-on: ubuntu-latest

    steps:
      - name: Check out code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5  # Updated from v4 to v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: ${{ env.POETRY_VERSION }}
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: Build package
        run: poetry build

      - name: Validate package with twine
        run: |
          poetry run pip install twine
          poetry run twine check dist/*

      - name: Test package installation
        run: |
          # Test installing the built package in a clean environment
          poetry run pip install dist/*.whl
          # TODO: Add a simple import test for your package
          poetry run python -c "import ${{ env.PACKAGE_NAME }}; print('Package import successful')"

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4  # Updated from v3 to v4
        with:
          name: python-package
          path: dist/

  # ===========================================================================
  # INTEGRATION CHECK
  # ===========================================================================
  # Final job that depends on all others - useful for branch protection rules
  integration:
    name: Integration Check
    runs-on: ubuntu-latest
    needs: [pre-commit, test, type-check, build]
    if: always()  # Run even if some jobs fail

    steps:
      - name: Check all jobs status
        run: |
          echo "Pre-commit: ${{ needs.pre-commit.result }}"
          echo "Tests: ${{ needs.test.result }}"
          echo "Type Check: ${{ needs.type-check.result }}"
          echo "Build: ${{ needs.build.result }}"

          # Fail if any critical job failed
          if [[ "${{ needs.pre-commit.result }}" == "failure" ||
                "${{ needs.test.result }}" == "failure" ||
                "${{ needs.type-check.result }}" == "failure" ||
                "${{ needs.build.result }}" == "failure" ]]; then
            echo "❌ One or more critical jobs failed"
            exit 1
          else
            echo "✅ All critical jobs passed"
          fi

      - name: Post success comment on PR
        if: github.event_name == 'pull_request' && success()
        uses: actions/github-script@v7  # Updated from v6 to v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: '✅ All CI checks passed! This PR is ready for review.'
            })

# =============================================================================
# WORKFLOW OPTIMIZATION SETTINGS
# =============================================================================
# Global settings to improve workflow performance and reliability

# Concurrency settings to cancel redundant workflow runs
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true          # Cancel previous runs when new commits are pushed

# =============================================================================
# CHECKLIST FOR NEW PROJECTS
# =============================================================================
# When using this template, customize the following:
#
# 1. PROJECT-SPECIFIC UPDATES:
#    - [ ] Update PACKAGE_NAME environment variable
#    - [ ] Update branch names if not using main/master/develop
#    - [ ] Update Python versions in test matrix
#    - [ ] Update source directory paths if not using src/
#
# 2. OPTIONAL CONFIGURATIONS:
#    - [ ] Add Windows/macOS to test matrix if cross-platform support needed
#    - [ ] Enable Codecov token in repository secrets for coverage reporting
#    - [ ] Add database services if your tests need them
#    - [ ] Add caching for additional dependencies (npm, etc.)
#
# 3. REPOSITORY SETTINGS:
#    - [ ] Enable branch protection rules requiring CI to pass
#    - [ ] Set up required status checks for all critical jobs
#    - [ ] Configure auto-merge for dependabot PRs (optional)
#
# 4. SECRETS TO ADD (Repository Settings → Secrets and Variables → Actions):
#    - [ ] PYPI_API_TOKEN: For automated releases (in release workflow)
#    - [ ] TEST_PYPI_API_TOKEN: For test releases
#
# 5. GITHUB REPOSITORY SETTINGS:
#    - [ ] Go to Settings → Branches → Add protection rule for main branch
#    - [ ] Require status checks: pre-commit, test, type-check, build
#    - [ ] Require up-to-date branches before merging
#    - [ ] Require signed commits (optional, for higher security)
#
# 6. PERFORMANCE OPTIMIZATIONS:
#    - [ ] Monitor workflow run times and adjust caching as needed
#    - [ ] Consider splitting jobs further if they become too slow
#    - [ ] Add timeout-minutes to jobs that might hang
#
# 7. ADDITIONAL FEATURES TO CONSIDER:
#    - [ ] Add security scanning with CodeQL or Bandit
#    - [ ] Add dependency vulnerability scanning with Safety
#    - [ ] Add code quality metrics with SonarCloud
#    - [ ] Add performance benchmarking for performance-critical code
#
# 8. BADGES FOR README:
#    Add these badges to your README.md:
#    [![CI](https://github.com/your-username/your-project-name/workflows/CI/badge.svg)](https://github.com/your-username/your-project-name/actions?query=workflow%3ACI)
#    [![Python](https://img.shields.io/pypi/pyversions/your-project-name.svg)](https://pypi.org/project/your-project-name/)
#    [![Coverage](https://img.shields.io/codecov/c/github/your-username/your-project-name)](https://codecov.io/gh/your-username/your-project-name)
#
# 9. WORKFLOW COMMANDS FOR LOCAL TESTING:
#    poetry run pre-commit run --all-files    # Run all pre-commit checks
#    poetry run coverage run -m unittest discover tests  # Run tests with coverage
#    poetry run coverage report               # Show coverage report
#    poetry run mypy src/                     # Run type checking
#    poetry build                             # Build package
#    poetry run twine check dist/*            # Validate package
#
# 10. MONITORING AND OPTIMIZATION:
#     - Monitor workflow execution times in the Actions tab
#     - Check cache hit rates and optimize cache keys if needed
#     - Consider matrix job optimization for faster feedback
#     - Use fail-fast: false strategically to get complete test results
